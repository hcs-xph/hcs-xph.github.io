[{"title":"android 获取View的宽高问题","date":"2017-06-06T14:30:00.000Z","path":"2017/06/06/get-view-wh/","text":"通常情况下我们在onCreate()、onStart()、onResume()获取View的宽高都是0，那是因为View的measure过程和Activity的生命周期不是同步进行的，不能保证在Activity的onCreate()、onStart()、onResume()方法执行时View已经测量完毕，所以不能获取到正确的宽高。下面介绍以下几种获取View宽高的方法： Activity/View的onWindowFocusChanged方法体内 View.post(runnable)方法/Handler.post(new Runnable) ViewTreeObserver View.measure 自定义View时获取宽高 通过LayoutParams获取 1、Activity/View的onWindowFocusChanged方法体内可以在Activity或者View中重写该方法获取，该方法意思是View已经初始化完毕了，既然初始化完毕了自然就可以获取View的宽高了，但是该方法可能执行多次，当焦点变化时都会被调用。12345678@Overridepublic void onWindowFocusChanged(boolean hasWindowFocus) &#123; super.onWindowFocusChanged(hasWindowFocus); if(hasWindowFocus)&#123; int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); &#125;&#125; 2、View.post(runnable)方法/Handler.post(new Runnable)该方式获取主要是通过view的post将一个Runnable添加到消息队列的尾部，等待Looper调用此Runnable的时候，view也已经初始化好了。同理通过Handler的post方式也是一样，不过Handler必须是主线程的Handler,可以在主线程创建也可以通过new Handler(Looper.getMainLooper)方式创建。两者的相同之处都是往消息队列尾部添加消息等待执行，不同点是View要执行必须要保证它已经attached到了Window上。 3、ViewTreeObserver这个类是整个View树结构的观察者，可以通过该类的OnGlobalLayoutListener接口来获取。 因为当View树的内部结构的View可见性或者状体改变时该接口都会被调用。具体使用如下：123456789ViewTreeObserver observer = view.getViewTreeObserver();observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeGlobalOnLayoutListener(this); int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); &#125;&#125;); 注意：removeGlobalOnLayoutListener()方法已经过时，可以调用removeOnGlobalLayoutListener()方法，但是该方法要求API &gt;= 16。 4、View.measure完整方法名为measure(int widthMeasureSpec,int heightMesureSpec) 通过手动对view测量得到宽高，这种方法较为复杂，要分情况处理，根据view的LayoutParams来分: match_parent根据View的measure过程分析构造此种MeasureSpec需要知道父容器的剩余空间，而此时无法知道，所以理论上不能测出View的大小。 wrap_content 12345int widthMeasureSpec = View.MeasureSpec.makeMeasureSpec((1 &lt;&lt; 30) - 1, View.MeasureSpec.AT_MOST);int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec((1 &lt;&lt; 30) - 1, View.MeasureSpec.AT_MOST);view.measure(widthMeasureSpec,heightMeasureSpec);int width = view.getMeasuredWidth());int height = view.getMeasuredHeight()); 注意到（1 &lt;&lt; 30）-1，通过分析MeasureSpec的实现可以知道，View的尺寸使用30位二进制表示，也就是说最大是30个1（即2^30 -1），也就是（1 &lt;&lt; 30）-1，在最大化模式下我们用View理论上支持的最大值去构造MeasureSpec是合理的。 5、自定义View时获取宽高有时在自定义控件的时候会需要用到宽高值，大部分的时候可以在onLayout方法里面获取到真实宽高值，同样也可以用上述几种方法获取。首先让自定义的View实现onGlobalListener接口，需要实现onGlobalLayout方法.然后在onAttachedToWindow()添加12345@Overrideprotected void onAttachedToWindow() &#123; super.onAttachedToWindow(); getViewTreeObserver().addOnGlobalLayoutListener(this);&#125; 记得要在onDetachedFromWindow()删除12345@Overrideprotected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); getViewTreeObserver().removeOnGlobalLayoutListener(this);(API 16)&#125; 接着在onGlobalLayout方法中获取宽高即可，因为要调用多次，可以设立个标志位.12345678private boolean isFirst = true;@Overridepublic void onGlobalLayout() &#123; if (isFirst) &#123; int height = getHeight(); isFirst = false; &#125;&#125; 6、LayoutParams获取对于xml文件里面设置了具体宽高的view可以通过view.getLayoutParams().height/width获取到宽高。优点:能及时获取到，操作简单；缺点：不够通用，没有设置具体宽高的获取到的值就是0了。","tags":[{"name":"android","slug":"android","permalink":"https://github.com/hcs-xph/tags/android/"},{"name":"View","slug":"View","permalink":"https://github.com/hcs-xph/tags/View/"}]},{"title":"android JNI简单开发流程","date":"2017-04-25T14:30:00.000Z","path":"2017/04/25/jni-one/","text":"一、什么是JNIJNI是Java Native Inteface 开发协议，而NDK是Native Develop Kits(本地开发工具包)，是android提供用来做JNI开发包。首先我们来看下JNI基本数据类型： JNI基本数据类型协议： Java类型 JNI别名 本地类型 boolean jboolean unsigned char byte jbyte signed char char jchar unsigned short short jshort short int jnit int long jlong long long float jfloat float double jdouble double 二、JNI配置流程JNI配置流程需要以下几个步骤： 1.将下载好的ndk开发包解压到没有中文和空格的目录； 2.找到解压好的ndk目录下的ndk-build所在的目录，配置到电脑的PATH环境变量中，主要为了使用ndk-build命令。 3.给AS关联NDK: a.在工程local.properties中添加 “ndk.dir=ndk目录” b.在工程跟目录gradle.properties中添加配置(主要是为了兼容老的ndk) “android.useDeprecatedNdk=true” 三、NDK开发流程通过以上几个步骤我们就可以开始写我们的JNI程序了。这里主要有一下几个步骤： 1.在Java文件里面写native代码； 2.在main目录下创建jni目录，写C代码生成头文件； 3.配置动态链接库的名称； 4.加载动态链接库； 这里举个小的案例： 第一步：定义native方法java代码部分：12345678910111213141516/** * Java调用对应的C代码 * Created by：hcs on 2017/1/10 10:48 * e_mail：aaron1539@163.com */public class JNI &#123; &#123; System.loadLibrary(\"hello\"); &#125; /** * 定义native方法 * 作用：调用C代码对应的方法 * @return */ public native String sayHello();&#125; 第二步：在main目录下新建jni目录创建c代码：123456789101112131415#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;jni.h&gt;/** * jstring:返回值 * Java_全类名_方法名 * JNIEnv* env:里面有很多方法 * jobject jobj：谁调用了这个方法就是谁的实例 * 当前就是JNI.this **/jstring Java_com_mph_ndktest_JNI_sayHello(JNIEnv* env,jobject jobj)&#123; //jstring (*NewStringUTF)(JNIEnv*,const jchar*);该方法返回一个string char* text = \"I am from c\"; return (*env)-&gt;NewStringUTF(env,text);&#125; 第三步：在model中的build.gradle中android节点中的defaultConfig中声明：1234ndk&#123; moduleName \"hello\" //so文件：lib+moduleName+.so abiFilters \"armeabi\",\"x86\",\"arm64-v8a\"//cpu的类型&#125; 第四步：直接可以使用JNI类了123String result = new JNI().sayHello();//Log.d(\"debug\",\"hello--&gt;\"+result);Toast.makeText(this,result,Toast.LENGTH_SHORT).show(); 四、根据Java native方法生成动态c对应方法的两种方式 在工程目录下，通过Terminal命令进入app\\src\\main\\java目录，执行：javah 需要生成C方法的对应java类的全类名; 在项目的app/build/intermaediates/classes/debug/进入本地磁盘该目录通过命令行下执行：javah -classpath . -jni 全类名,会在该目录下生成文件。 到此JNI开发的基本步骤使用已经讲解完毕。","tags":[{"name":"android","slug":"android","permalink":"https://github.com/hcs-xph/tags/android/"},{"name":"JNI","slug":"JNI","permalink":"https://github.com/hcs-xph/tags/JNI/"},{"name":"NDK","slug":"NDK","permalink":"https://github.com/hcs-xph/tags/NDK/"}]},{"title":"利用Gradle发布开源项目到JCenter","date":"2017-04-23T00:42:00.000Z","path":"2017/04/23/jcenter-release/","text":"很多时候我们自己写好一个开源项目托管于github上，想要让别人能够更方便的引用自己的项目，我们可以借助于as将我们的开源项目发布到JCenter上共别人引用。下面将介绍怎么发布自己的开源项目到jcenter。 一、托管JCenter好处别人引用你的项目只需在build.gradle中一句话引用你的项目，如(引用的是鄙人github上的一个项目)：1compile 'com.mph.library:library:1.0.4' 这样就免去了频繁拷贝的烦恼。 二、软件环境这里是我本机环境的一个配置： android studio：2.2.2 com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.1 com.github.dcendents:android-maven-gradle-plugin:1.5 com.android.tools.build:gradle:2.2.2 三、具体步骤1.在项目根目录下build.gradle配置如下：12345678910111213buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.2' classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'//用于打包Maven所需文件 classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.1'//用于上传Maven生成的文件到bintray插件 // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 其他默认配置即可。 2.在library中的build.gradle中配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121apply plugin: 'com.android.library'apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray'version = \"1.0.0\"android &#123; compileSdkVersion 25 buildToolsVersion \"24.0.0\" resourcePrefix \"basedroid\"//这个可以随便写 defaultConfig &#123; minSdkVersion 14 targetSdkVersion 25 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.0.1' testCompile 'junit:junit:4.12' compile 'org.greenrobot:eventbus:3.0.0' compile 'com.jakewharton:butterknife:8.4.0' compile 'com.github.bumptech.glide:glide:3.7.0' compile 'com.android.support:recyclerview-v7:25.0.1' compile 'com.squareup.okhttp3:okhttp:3.5.0' compile 'com.squareup.okio:okio:1.11.0' compile 'com.google.code.gson:gson:2.8.0'&#125;def siteUrl = 'https://github.com/hcs-xph/BaseDroid' //项目主页 def gitUrl = 'https://github.com/hcs-xph/BaseDroid.git' //git仓库url group \"com.mph.library\" //通常写model包名install&#123; repositories.mavenInstaller&#123; pom&#123; project&#123; packaging 'aar' name 'Basic android development framework'//项目描述 url siteUrl // 设置许可证 licenses &#123; license &#123; name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' &#125; &#125; developers&#123;//开发者信息 developer&#123; id 'hechangsheng' name 'Aaron' email 'q2589162301@gmail.com' &#125; &#125; scm&#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;//生成sourcs.jartask sourcesJar(type: Jar)&#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125;task javadoc(type: Javadoc)&#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;//生成javadoc.jartask javadocJar(type:Jar, dependsOn: javadoc)&#123; classifier = 'javadoc' from javadoc.destinationDir&#125;//javadoc的配置，一定要记得配置，否则会出现编译时注解错误javadoc&#123; options&#123; encoding \"UTF-8\" charSet 'UTF-8' author true version true links \"http://docs.oracle.com/javase/7/docs/api\" title \"BaseDroid\" &#125;&#125;artifacts&#123; archives javadocJar archives sourcesJar&#125;Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())/** * userOrg:为bintray帐号信息里面的Organization Id * repo:为创建的仓库名称 * 如果以上没找到或者写错会报如下错： * （Could not create package 'huangxuanheng/maven/fragmentstack':HTTP/1.1 404 Not Found [message:Repo 'maven' was not found]） **/bintray&#123; user = properties.getProperty(\"bintray.user\") key = properties.getProperty(\"bintray.apikey\") configurations = ['archives'] pkg&#123; userOrg=\"maverick\" repo = \"mph\" name = \"BaseDroid\" //发布到JCenter上的项目名字 websiteUrl = siteUrl vcsUrl = gitUrl licenses = [\"Apache-2.0\"] publish = true &#125;&#125; 做好以上配置后只需要在根目录下的local.properties文件配置bintray账户和ApiKey即可：12bintray.user=your_user_namebintray.apikey=your_apikey 这样配置就大功告成了，此时需要重新Rebuild下项目，之后在as Terminal中执行‘gradlew bintrayUpload’直接上传即可。如果有必要的话需要在执行上传语句之前，先运行‘gradlew install’语句。登录bintray找到自己刚刚上传的库，然后在点击add to jcenter。如下图所示位置这里因为我这个OkDroid项目已经上传了所以没有add to jcenter字样。 4.可能遇到的问题1.上传到Bintray- HTTP/1.1 404 Not Found [message:Repo ‘maven’ was not found]问题。出现这个问题的原因可能是名为maven的仓库（不一定是叫maven，名字只要和bintray网站建立仓库时的名称一致即可）没有建立，或者建立了仓库，但是名称不叫maven，又或者组织名称不叫coolcode，因为项目上传的路径为：组织ID/仓库名称/项目名，所以检查组织ID和仓库名称是否正确即可解决问题。 2.gralde执行遇到Unsupported major.minor version 52.0错误。 确认是否本地环境是JDK版本低版本，而gradle是高版本的情况，比如我的JDK是1.7而gradle是2.14; Android Studio中的SDK platform tools API是不是升级到了24、25这样的高版本，如果是的话，去studio安装目录下看看jre下面的Java版本是不是1.8，如果那里是1.8的话，最好是把电脑中的环境变量java版本改成1.8; 3.Could not create package ‘zengcanxiang/maven/NetWorkUtils’: HTTP/1.1 401 Unauthorized [message:This resource requires authentication]。说明配置的用户名或者apiKey出现问题。 4.javadoc乱码问题。需要在model中build.gradle中添加如下配置：12345678910javadoc&#123; options&#123; encoding \"UTF-8\" charSet 'UTF-8' author true version true links \"http://docs.oracle.com/javase/7/docs/api\" title \"BaseDroid\" &#125;&#125; 到此已经成功上传自己的项目了。注意上传成功是需要审核的不过挺快的。之后就可以到项目中引用了。有什么问题可以留言交流。","tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://github.com/hcs-xph/tags/Gradle/"},{"name":"JCenter","slug":"JCenter","permalink":"https://github.com/hcs-xph/tags/JCenter/"},{"name":"binray","slug":"binray","permalink":"https://github.com/hcs-xph/tags/binray/"}]},{"title":"okhttp 3.x源码解析(一)","date":"2017-04-22T04:46:00.000Z","path":"2017/04/22/okhttp-one/","text":"在看源码之前相信也对okhttp使用有一定的了解了，这里不再做okhttp使用的讲解。直接以一个请求为例了解okhttp到底是怎么的一个请求流程。在这里我们首先需要了解的的几个类：OkhttpClient、RealCall、Dispatcher、AyscCall(异步任务)、CallBack(回调接口)等。 以get请求为例123456789101112131415Request request = new Request.Builder() .url(\"https://www.baidu.com/\") .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125; &#125;); 1.OkHttpClient的newCall方法首先我们来看client.newCall(),调用newCall方法创建了一个RealCall实例传入自身引用进去(此时RealCall方法持有okhttpClient引用)并调用RealCall的enqueue()方法,下面为enqueue代码：12345678@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 在该方法中调用了okhttpClient的dispatcher方法得到一个dispatcher对象，在OkthhpClient方法中Builder内部类中new出来的。再调用Dispatcher的enqueue()方法同时new一个AsyncCall（CallBack）异步任务类传入构造方法; 2.Dispatcher的enqueue方法12345678910synchronized void enqueue(AsyncCall call) &#123; //正在运行的异步任务队列数量小于最大请求数，添加请求，线程池执行该任务 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; //放到异步任务准备队列中 readyAsyncCalls.add(call); &#125; &#125; 其中Dispatcher包含了线程池和三个队列(readyAsyncCalls:保存等待执行的异步请求、runningAsyncCalls：保存正在运行的异步请求、runningSyncCalls:保存正在执行的同步请求)。如下：12345678/** 线程池*/private ExecutorService executorService;/** 保存准备运行的异步请求（当运行请求超过限制数时会保存在此队列） */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/** 保存正在运行的异步请求. */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** 保存正在运行的同步请求. */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); 线程池执行该异步任务，会执行该任务AsyncCall的run方法，该AsyncCall是RealCall内部类并且是NamedRunnable子类有Callback responseCallback属性主要用于回调，而NamedRunnable实现了Runnable接口，该类主要是给线程设置name，并调用了抽象的execute方法。该抽象方法主要在AsyncCall中实现，从这开始都是在子线程中执行了。 3.AsyncCall的execute()方法1234567891011121314151617181920212223242526@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; //由getResponseWithInterceptorChain()来执行网络请求,得到response Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; //失败后回调Callback的onFailure方法 responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); &#125; else &#123; signalledCallback = true; //成功后回调CallBack的onResponse方法 responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; //最后调用Dispatcher的finish方法 client.dispatcher().finished(this); &#125; &#125; 重点在getResponseWithInterceptorChain()；方法，先看Dispatcher的finished(this)方法。 4.finished()方法1234567891011121314151617181920void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call, true); &#125;private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; //移除当前执行完成的任务 if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\"); //接着promoteCalls()该方法会再去从异步准备运行的队列中移除任务，添加任务到正在运行中队列直到添加满再去执行 if (promoteCalls) promoteCalls(); //得到异步和同步任务正在执行数 runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback;//??这个在哪里赋值 &#125; //线程池为空且设置了该线程，执行回调线程 if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; 代码解释主要看代码中的注释，这里重点看下promoteCalls():1234567891011121314private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // //容量已满，不提交新请求 if (readyAsyncCalls.isEmpty()) return; // 没有正在准备的请求，返回 //从readyAsyncCalls中循环取出AsyncCall直到达到容量上限 for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // 达到上限后返回 &#125; &#125; 之后重点看getResponseWithInterceptorChain(); 5.getResponseWithInterceptorChain()方法1234567891011121314151617Response getResponseWithInterceptorChain() throws IOException &#123; // 构建全栈拦截器. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors());//自定义拦截器 interceptors.add(retryAndFollowUpInterceptor);//重试拦截器 interceptors.add(new BridgeInterceptor(client.cookieJar()));//桥接拦截器 interceptors.add(new CacheInterceptor(client.internalCache()));//缓存拦截器 interceptors.add(new ConnectInterceptor(client));//连接拦截器 if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors());//用户预定义的网络拦截器 &#125; interceptors.add(new CallServerInterceptor(forWebSocket));//调用服务拦截器 //内部通过责任链模式来使用拦截器 Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest);//获取Response &#125; 这个方法在call.execute(同步请求)方法也调用到了,Okhttp真正发出网络请求，解析返回结果的就是该方法。 6.getResponseWithInterceptorChain()方法1234567891011121314151617Response getResponseWithInterceptorChain() throws IOException &#123; // 构建全栈拦截器. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors());//自定义拦截器 interceptors.add(retryAndFollowUpInterceptor);//重试拦截器 interceptors.add(new BridgeInterceptor(client.cookieJar()));//桥接拦截器 interceptors.add(new CacheInterceptor(client.internalCache()));//缓存拦截器 interceptors.add(new ConnectInterceptor(client));//连接拦截器 if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors());//用户预定义的网络拦截器 &#125; interceptors.add(new CallServerInterceptor(forWebSocket));//调用服务拦截器 //内部通过责任链模式来使用拦截器 Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest);//获取Response &#125; 在这里Interceptors这个拦截器集合是如何调用的呢？主要看RealInterceptorChain 中的proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,RealConnection connection)这个方法12345678910111213public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; ....... // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); ...... return response; &#125; 该方法通过内部新建RealInterceptorChain对象传入Interceptor的intercept方法，执行该方法。intercept方法中又会调用RealInterceptorChain方法达到循环取出Interceptor执行的目的。 几个拦截器 RetryAndFollowUpInterceptor重试拦截器 重试与重定向拦截器，用来实现重试和重定向功能，内部通过while(true)死循环来进行重试获取Response(有重试上限，超时会抛异常)。followUpRequest主要用来根据响应码来判断属于哪种行为触发的重试和重定向(比如未授权，超时，重定向等)，然后构建响应的Request进行下一次请求。当然，如果没有触发重新请求就会直接返回Response。 BridgeInterceptor桥接拦截器 桥接拦截器，用于完善请求头，比如Content-Type、Content-Length、Host、Connection、Accept-Encoding、User-Agent等等，这些请求头不用用户一一设置，如果用户没有设置该库会检查并自动完善。另外，这里会进行加载和回调Cookie。 CacheInterceptor缓存拦截器 缓存拦截器，首先根据Request中获取缓存的Response,然后根据用于设置的缓存策略来进行一步判断缓存的Response是否可用以及是否发送网络请求(CacheControl.FORCE_CACHE因为不会发送网络请求，所以networkRequest一定为空)。如果从网络中读取，此时再次根据缓存策略来决定是否缓存响应。 ConnectInterceptor连接拦截器 连接拦截器，用于打开一个连接到远程服务器。也就是通过StreamAllocation获取HttpStream和RealConnection对象，以便后续读写。 12345678910@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125; 实际上建立连接就是创建了一个HttpCodec对象，它将在后面的步骤中被使用，是HTTP协议操作的抽象，有两个实现：Http1Codec、Http2Codec。分别是对HTTP/1.1 和HTTP/2版本的实现。在Http1Codec中，利用Okio对Socket的读写操作进行封装。创建HttpCodec的过程里面涉及了StreamAllocation、RealConnection等，概括就是找到一个可用的RealConnection,再利用RealConnection的输入输出(Buffered和BufferedSkin)创建HttpCodec对象供后续操作。 CallServerInterceptor服务拦截器调用服务拦截器，通过HttpStream依次进行写请求头、请求体、读响应头、读响应体。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); //向服务器发生request header httpCodec.writeRequestHeaders(request); Response.Builder responseBuilder = null; //如果有 request body if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; // 如果请求中有一个“Expect：100-continue”头，请等待“HTTP / 1.1 100 Continue”响应， // 然后再发送请求主体。 如果我们没有这样做，请返回我们所获得的（例如4xx响应）， // 而不会传输请求体。 if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) &#123; httpCodec.flushRequest(); responseBuilder = httpCodec.readResponseHeaders(true); &#125; if (responseBuilder == null) &#123; // 如果不满足上述条件，就写请求体 Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength()); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); //将请求实体内容通过Okio发送到服务器 request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); &#125; else if (!connection.isMultiplexed()) &#123; streamAllocation.noNewStreams(); &#125; &#125; httpCodec.finishRequest(); if (responseBuilder == null) &#123; //得到responseBuilder responseBuilder = httpCodec.readResponseHeaders(false); &#125; //得到response Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; //如果有 response body，就在response的基础上加上body构造一个新的 Response 对象 response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength()); &#125; return response; &#125; 这里核心工作都是由HttpCodec对象完成，而HttpCodec实际上是利用Okio，Okio还是用的Socket完成网络。这里对于okhttp一个请求的基本流程已经介绍完，后续会带来更精彩分析。","tags":[{"name":"android","slug":"android","permalink":"https://github.com/hcs-xph/tags/android/"},{"name":"okhttp","slug":"okhttp","permalink":"https://github.com/hcs-xph/tags/okhttp/"}]}]